<?php

namespace tad\Codeception\Command\Generator;


use Codeception\Lib\Di;
use Codeception\Lib\ModuleContainer;
use Codeception\Util\Template;
use phpDocumentor\Reflection\DocBlock\Tags\Generic;
use phpDocumentor\Reflection\DocBlockFactory;

class GherkinSteps
{
    protected $template = <<<EOF
<?php  //[STAMP] {{hash}}
namespace {{namespace}}_generated;

// This class was automatically generated by the steppify task
// You should not change it manually as it will be overwritten on next steppify run
// @codingStandardsIgnoreFile

trait {{name}}GherkinSteps{{postfix}}
{
        
    /**
     * [!] Utility method is generated from steppify task.
     *
     * Converts any TableNode found in an array to an array of associative arrays.
     *
     * @param array \$args An array of arguments that should be parsed to convert TableNode
     *              to arrays.
     * @param array \$iterations Passed by reference; will be set to empty array if there
     *              there are no TableNode arguments among the arguments, will be set to
     *              an array of function call arguments if found.
     */
    public function _convertTableNodesToArrays(array \$args, &\$iterations = []) {
        foreach(\$args as \$key => \$value) {
            if(is_a(\$value, 'Behat\Gherkin\Node\TableNode')){
                \$rows = \$value->getRows();
                \$keys = array_shift(\$rows);
                \$array_value = array_map(function(array \$row) use (\$keys) {
                    return array_combine(\$keys,\$row);
                }, \$rows);
                
                \$iterations[] = array_replace(\$args, [\$key => \$array_value]);
            }
        }
        
        return \$args;
    }
    
    {{methods}}
}

EOF;

    protected $methodTemplate = <<<EOF
    /**
     * [!] Method is generated from steppify task. Documentation taken from corresponding module.
     *
     {{gherkinDoc}}
     *
     * @see \{{module}}::{{method}}()
     */
    public function {{action}}({{params}}) {
        \$args = \$this->_convertTableNodesToArrays(func_get_args(), \$iterations);
        
        if(!empty(\$iterations)) {
            \$returnValues = [];
            foreach(\$iterations as \$iteration){
                \$returnValues[] = \$this->getScenario()->runStep(new \Codeception\Step\Action('{{method}}', \$iteration));
            }
            
            return \$returnValues;
        }
        
        return \$this->getScenario()->runStep(new \Codeception\Step\Action('{{method}}', \$args));
    }
EOF;

    protected $stopWords = ['see', 'have', 'and', 'or', 'with', 'to', 'in'];
    protected $jumpingStopWords = ['see', 'have', 'with', 'in'];

    /**
     * @var string
     */
    protected $module;

    /**
     * @var array
     */
    protected $settings;

    /**
     * @var Di
     */
    protected $di;

    /**
     * @var ModuleContainer
     */
    protected $moduleContainer;

    /**
     * @var array
     */
    protected $actions;

    /**
     * @var array
     */
    protected $currentMethodConfig;

    public function __construct($module, array $settings = [])
    {
        $this->settings = $settings;
        $this->module = $module;

        $this->di = new Di();
        $this->moduleContainer = new ModuleContainer($this->di, $settings);

        $this->moduleContainer->create($module);

        $this->actions = $this->moduleContainer->getActions();
    }

    /**
     * @return string
     */
    public function produce()
    {
        $namespace = rtrim($this->settings['namespace'], '\\');


        $this->settings = $this->normalizeModuleSettings($this->settings);

        return (new Template($this->template))
            ->place('hash', $this->generateHash())
            ->place('namespace', $namespace ? $namespace . '\\' : '')
            ->place('name', ucfirst($this->settings['name']))
            ->place('postfix', $this->settings['postfix'])
            ->place('methods', $this->getMethods())
            ->produce();
    }

    /**
     * @return string
     * @gherkin given, when, then
     */
    protected function getMethods()
    {
        // generate the method template
        $methods = [];
        foreach ($this->actions as $method => $module) {

            if ($this->shouldSkipMethod($module, $method)) {
                continue;
            }

            $methods[] = (new Template($this->methodTemplate))
                ->place('module', ltrim($module, '\\'))
                ->place('method', $method)
                ->place('gherkinDoc', $this->getGherkingDoc($module, $method))
                ->place('action', 'step_' . $method)
                ->place('params', $this->getParams($module, $method))
                ->produce();
        }

        return implode(PHP_EOL . PHP_EOL, $methods);
    }

    protected function shouldSkipMethod($module, $method)
    {

        $module = '\\' .trim($module,'\\');

        $configSkipped = !empty($this->settings['steps-config']['modules'][$module]['exclude']) ?
            (array)$this->settings['steps-config']['modules'][$module]['exclude']
            : [];

        if (in_array($method, $configSkipped)) {
            return true;
        }

        $docBlockFactory = DocBlockFactory::createInstance();
        $docBlock = (new \ReflectionMethod($module, $method))->getDocComment();

        if (empty($docBlock)) {
            return false;
        }

        $docBlock = $docBlockFactory->create($docBlock);
        $gherkinTags = $docBlock->getTagsByName('gherkin');

        if (empty($gherkinTags)) {
            return false;
        }

        /** @var Generic $tag */
        $tag = $gherkinTags[0];
        return preg_match('/(N|n)(o|O)/', $tag->getDescription()->render());
    }

    /**
     * @param string $module
     * @param \ReflectionMethod $method
     *
     * @return string
     */
    protected function getGherkingDoc($module, $method)
    {
        $docBlockFactory = DocBlockFactory::createInstance();
        $reflectionMethod = new \ReflectionMethod($module, $method);
        $docComment = $reflectionMethod->getDocComment();

        $module = '\\' .trim($module,'\\');

        $methodConfig = !empty($this->settings['steps-config']['modules'][$module]['methods'][$method]) ?
            $this->settings['steps-config']['modules'][$module]['methods'][$method] :
            [];

        if (empty($methodConfig['generates'])) {
            $steps = $this->getStepsFromMethodDocBlock($docComment, $docBlockFactory);
        } else {
            $steps = $methodConfig['generates'];
        }

        return $this->generateGherkinStepsNotations($steps, $module, $method, $methodConfig);
    }

    /**
     * @param array $steps
     * @param string $module
     * @param \ReflectionMethod $method
     * @param array $methodConfig
     *
     * @return string
     */
    protected function generateGherkinStepsNotations(array $steps, $module, $method, array $methodConfig)
    {
        $ref = new \ReflectionMethod($module, $method);
        $parameters = $ref->getParameters();

        $lines = $this->getGherkinNotationLinesFor($method, $parameters, $steps, $methodConfig);

        $doc = implode(PHP_EOL . "\t ", $lines);

        return $doc;
    }

    /**
     * @param \ReflectionMethod $method
     * @param \ReflectionParameter[] $parameters
     * @param array $steps
     *
     * @return array
     */
    protected function getGherkinNotationLinesFor($method, $parameters, $steps, array $methodConfig)
    {
        $parameterNames = $this->extractParameterNames($parameters);

        if (!empty($methodConfig['step'])) {
            $lines = [];
            $generates = (array)$methodConfig['generates'];
            array_walk($generates, function ($generatedStep) use ($methodConfig, &$lines) {
                $stepLines = array_map(function ($stepTemplate) use ($generatedStep) {
                    return '* @' . ucfirst($generatedStep) . ' /' . trim($stepTemplate, '/') . '/';
                }, (array)$methodConfig['step']);
                $lines = array_merge($lines, $stepLines);
            });
        } else {
            $wordsWithoutStopwords = $words = array_map('strtolower', preg_split('/(?=[A-Z_])/', $method));
            $parameterNamesAndStopwords = $this->extractParameterNamesAndStopWords($words, $parameterNames,
                $wordsWithoutStopwords);
            $lines = $this->buildGherkinLinesForSteps($steps, $parameters, $wordsWithoutStopwords,
                $parameterNamesAndStopwords);
            $lines = array_map(function ($line) {
                return $line . '/';
            }, $lines);
        }

        return $lines;
    }

    /**
     * @param $parameters
     * @return array
     */
    protected function extractParameterNames($parameters)
    {
        $parameterNames = [];
        if (!empty($parameters)) {
            $parameterNames = array_map(function (\ReflectionParameter $parameter) {
                return $parameter->getName();
            }, $parameters);
            return $parameterNames;
        }
        return $parameterNames;
    }

    /**
     * @param array $words
     * @param array $parameterNames
     * @param array $wordsWithoutStopwords
     * @return array
     */
    protected function extractParameterNamesAndStopWords($words, $parameterNames, &$wordsWithoutStopwords)
    {
        $parameterNamesAndStopwords = [];
        for ($i = 0; $i < count($words); $i++) {
            if (false !== ($parameterPos = array_search($words[$i], $parameterNames))) {
                $foo = $i > 0 && in_array($words[$i - 1], $this->stopWords) ?
                    $words[$i - 1] : 'and';
                $parameterNamesAndStopwords[$parameterNames[$parameterPos]] = $foo;
                unset($wordsWithoutStopwords[$i]);
                unset($wordsWithoutStopwords[$i - 1]);
                continue;
            }
        }
        return $parameterNamesAndStopwords;
    }

    /**
     * @param array $steps
     * @param \ReflectionParameter[] $parameters
     * @param array $wordsWithoutStopwords
     * @param array $parameterNamesAndStopwords
     *
     * @return array
     */
    protected function buildGherkinLinesForSteps(
        $steps,
        $parameters,
        $wordsWithoutStopwords,
        $parameterNamesAndStopwords
    ) {
        $lines = [];
        $parameterNames = $this->extractParameterNames($parameters);
        foreach ($steps as $step) {
            $lastLineIndex = empty($lines) ? 0 : count($lines);

            $lastLine = $lines[$lastLineIndex] = sprintf('* @%s /I %s', ucfirst(trim($step)),
                implode(' ', $wordsWithoutStopwords));

            foreach ($parameters as $parameter) {
                $parameterName = $parameter->getName();
                $parameterPosition = array_search($parameterName, $parameterNames);

                $stopWord = isset($parameterNamesAndStopwords[$parameterName]) ?
                    $parameterNamesAndStopwords[$parameterName]
                    : 'and';

                if (0 !== $parameterPosition ||
                    (isset($parameterNamesAndStopwords[$parameterName])
                        && in_array($parameterNamesAndStopwords[$parameterName], $this->jumpingStopWords)
                    )
                ) {
                    $stopWord = isset($parameterNamesAndStopwords[$parameterName]) ?
                        $parameterNamesAndStopwords[$parameterName]
                        : 'and';
                    $stopWordAndParameterName = $stopWord . ' ' . $parameterName;
                } else {
                    $stopWordAndParameterName = $parameterName;
                }

                if (!$parameter->isDefaultValueAvailable()) {
                    $lineFrags = explode(' ', $lines[$lastLineIndex]);
                    $lineLastWord = end($lineFrags);
                    if (!in_array($lineLastWord, $this->stopWords)
                        && $parameterPosition === 0
                        && !in_array($stopWord, $this->jumpingStopWords)
                    ) {
                        $resultLine = sprintf('%s :%s', $lines[$lastLineIndex], $parameterName);
                    } else {
                        $resultLine = sprintf('%s %s :%s', $lines[$lastLineIndex], $stopWordAndParameterName,
                            $parameterName);
                    }
                    $lines[$lastLineIndex] = $lastLine = $resultLine;
                } else {
                    $lastLine = sprintf('%s %s :%s', $lastLine, $stopWordAndParameterName, $parameterName);
                    $lines[] = $lastLine;
                }
            }
        }
        return $lines;
    }

    /**
     * @param string $module
     * @param string $method
     *
     * @return string
     */
    protected function getParams($module, $method)
    {
        $method = new \ReflectionMethod($module, $method);

        $params = $method->getParameters();

        if (empty($params)) {
            return '';
        }

        return implode(', ', array_map([$this, 'getEntryForParameter'], $params));
    }

    protected function generateHash()
    {
        return (md5(serialize($this->module) . serialize($this->settings)));
    }

    /**
     * @param \ReflectionParameter $parameter
     *
     * @return string
     */
    protected function getEntryForParameter(\ReflectionParameter $parameter)
    {
        if ($parameter->isArray()) {
            $type = '\Behat\Gherkin\Node\TableNode';
        } else {
            $class = $parameter->getClass();
            $type = empty($class) ? '' : $class->getName();
        }

        $name = $parameter->getName();
        $defaultValue = $parameter->isDefaultValueAvailable() ? $parameter->getDefaultValue() : false;

        $noDefaultValue = empty($parameter->isDefaultValueAvailable()) || is_array($defaultValue);
        if ($noDefaultValue && empty($type)) {
            return sprintf('$%s', $name);
        } elseif ($noDefaultValue) {
            return sprintf('%s $%s', $type, $name);
        } else {
            if ($defaultValue === null) {
                $defaultValue = 'null';
            } elseif (is_string($defaultValue)) {
                $defaultValue = "'" . $defaultValue . "'";
            }

            return sprintf('%s $%s = %s', $type, $name, $defaultValue);
        }
    }

    /**
     * @param $docComment
     * @param $docBlockFactory
     * @return array
     */
    protected function getStepsFromMethodDocBlock($docComment, $docBlockFactory)
    {
        $steps = ['given', 'when', 'then'];

        if (!empty($docComment)) {
            $docBlock = $docBlockFactory->create($docComment);
            $gherkinTags = $docBlock->getTagsByName('gherkin');

            if (!empty($gherkinTags)) {
                /** @var Generic $gherkingTag */
                $gherkingTag = reset($gherkinTags);
                $steps = preg_split('/\\s*,\\s*/', $gherkingTag->getDescription()->render());
                return $steps;
            }
            return $steps;
        }
        return $steps;
    }

    protected function normalizeModuleSettings(array $settings)
    {
        if (empty($settings['steps-config']['modules'])) {
            return $settings;
        }

        $normalized = [];
        foreach ($settings['steps-config']['modules'] as $key => $value) {
            $normalized['\\' . trim($key, '\\')] = $value;
        }

        $settings['steps-config']['modules'] = $normalized;

        return $settings;
    }
}
